---
title: "Stat 400 Project"
authors: "Nathan Hemenway, Mark Hinds, Ian Hall"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
#testing github
library(tidyverse)

#create starting positions and state function
starting_vals <- function(num_subjects, I_0, x_dim, y_dim){
  
  #Infect I_0 many starting subjects
  subjects <- rep('S', num_subjects)
  infect <- sample(x = 1:num_subjects, size=I_0, replace=FALSE)
  subjects[infect] <- 'I'
  
  #Storage for x, y starting positions for the subjects
  start_x <- runif(n=num_subjects, min=0, max=x_dim)
  start_y <- runif(n=num_subjects, min=0, max=y_dim)
  
  #Put into a data frame
  df <- as.data.frame(cbind(as.numeric(start_x), as.numeric(start_y), subjects))
  colnames(df)[1] <- 'x'
  colnames(df)[2] <- 'y'
  return(df)
}

#Random step length function
get_step_length <- function(df, x_dim, y_dim){
  step_lengths <- rnorm(n=nrow(df), mean=min(x_dim, y_dim)/4, sd=min(x_dim, y_dim)/12)
  return(step_lengths)
}

#Random step direction function
get_step_direction <- function(length_vec){
  direction <- runif(n=length(length_vec), min=0, max=2*pi)
}

#Get delta_x, delta_y
get_delts <- function(length_vec, direc_vec){
  delta_x <- length_vec * cos(direc_vec)
  delta_y <- length_vec * sin(direc_vec)
  return(cbind(delta_x, delta_y))
}

#Function for getting updated coordinates
update_coords <- function(og_df, delta_df){
  new_mx <- matrix(data=NA, nrow=nrow(og_df), ncol=3)
  new_df <- data.frame(new_mx)
  new_df[,1] <- as.numeric(og_df[,'x']) + delta_df[,'delta_x']
  new_df[,2] <- as.numeric(og_df[,'y']) + delta_df[,'delta_y']
  new_df[,3] <- og_df[,3]
  colnames(new_df) <- c('x', 'y', 'subjects')
  
  new_df
}

coord_checker <- function(og_df, new_df, x_dim, y_dim){
  baddies <- NULL
  for(i in 1:nrow(new_df)){
    if(as.numeric(new_df[i, 'x']) > x_dim | as.numeric(new_df[i, 'x']) < 0 | as.numeric(new_df[i, 'y']) > y_dim | as.numeric(new_df[i, 'y']) < 0){
      baddies <- append(baddies, i)
    }
  }
  
  if(is.null(baddies)){
    return(new_df)
  }else{
  new_step <- get_step_length(new_df[i,], x_dim, y_dim)
  new_direction <- get_step_direction(new_step)
  new_change <- get_delts(new_step, new_direction)
  new_df <- update_coords(og_df[baddies,], new_change)
  full_df <- rbind(new_df, og_df[-baddies,])
  return(coord_checker(og_df, full_df, x_dim, y_dim))
  }
}

#Function for deciding if infections occured
#BUG -- If the mean_crit_dist is small, all infections go away!!
infection_status <- function(state, mean_crit_dist){
  
  current_infected <- state[state[,3]=='I',]
  current_suceptable <- state[state[,3]=='S',]
  current_removed <- state[state[,3]=='R',]
  current_non_infected <- rbind(current_suceptable, current_removed)
  
  #store new infection status
  new_status <- rep(NA, nrow(current_non_infected))
  newly_infected <- NULL
  
  #Check to see which suceptable subjects get infected
  #For loop
  for(i in 1:nrow(current_infected)){
    for(j in 1:nrow(current_non_infected)){
      x_i <- as.numeric(current_infected[i, 'x'])
      y_i <- as.numeric(current_infected[i, 'y'])
      x_s <- as.numeric(current_suceptable[j, 'x'])
      y_s <- as.numeric(current_suceptable[j, 'y'])
      crucial_distance <- rexp(1, 1/mean_crit_dist)
      d <- sqrt((x_i - x_s)^2 + (y_i - y_s)^2)
      if(d <= crucial_distance){
        new_status[j] <- 'I'
        newly_infected <- c(newly_infected, j)
      }else{new_status[j] <- 'S'}
    }
  }
  
  current_non_infected[newly_infected, 3] <- 'I'
  new_state <- rbind(current_infected, current_non_infected)
  
  # new_state <- c(new_status, current_infected[,3])
  return(new_state)
}

#simulation function
simulator <- function(days, num_subjects, x_dim, y_dim, I_0){
  initial_data <- starting_vals(num_subjects = num_subjects, x_dim=x_dim, y_dim=y_dim, I_0=I_0)
  end_day <- list()
  
  for(i in 1:days){
    
    if(i == 1){
    step_size <- get_step_length(initial_data, x_dim, y_dim)
    direction <- get_step_direction(step_size)
    change <- get_delts(step_size, direction)
    updated_positions <- update_coords(initial_data, change)
    checked_positions <- coord_checker(og_df=initial_data, new_df=updated_positions, x_dim=x_dim, y_dim=y_dim)
    new_status <- infection_status(checked_positions, 2)
    checked_positions[,3] <- new_status
    end_day[[i]] <- checked_positions
    
    }else{
    step_size <- get_step_length(initial_data, x_dim, y_dim)
    direction <- get_step_direction(step_size)
    change <- get_delts(step_size, direction)
    updated_positions <- update_coords(end_day[[i-1]], change)
    checked_positions <- coord_checker(og_df=end_day[[i-1]], new_df=updated_positions, x_dim=x_dim, y_dim=y_dim)
    new_status <- infection_status(checked_positions, 1/5)
    checked_positions[,3] <- new_status
    end_day[[i]] <- checked_positions
      
    }
  }
  return(end_day[[3]])
}

#Testing
df <- starting_vals(100, 2, 10, 10)
len <- get_step_length(df, 10, 10)
dir <- get_step_direction(len)
delts <- get_delts(len, dir)
newdf <- update_coords(df, delts)
coords <- coord_checker(df, newdf, 10, 10)
coords
new_status <- infection_status(coords, 2)
new_status

#S,I,R data
suceptable = function(){
  
}

recovered = function(){
  
}

infected = function(){
  
}


#reported monte carlo summary data
qd = c(0,25,50,75)
pos = c(99.3,99.2,98.7,92.7)
dncpv = c(69,53,46,33)
dncpt = c(26,32,43,42)
r0 = c(1.8,1.73,1.8,1.63)
mcsum = cbind(qd,pos,dncpv,dncpt,r0)
colnames(mcsum,c("Quarantine degree [%]",	"Percentage of size %",	"DNC peak value [cases]",	"DNC peaking time [days]",	"R0"))
```

This method is takes another approach. It's somewhat similar to the step function, but this one randomly changes the location of the individuals on a daily basis. Then at that point we gather its neighbors and calculate probability of them becoming infected. We keep track of their state (and update on if they would become infected or not) - then after a certain duration they heal or die. This is computationally easier than having a step function of hundreds of points all moving in space, where we have to calculate distance of each point coming in contact of an infected one. 

``` {r}
#for knn
#install.packages('dbscan') 
library("dbscan")
```

``` {r}
#variables
incubation_time <- rgamma(5, 6, (2/3))
crucial_distance <- rexp(5, 1/8)
n = 2000
starting_infected_prob = 0.005


#starting data and plot
starting_values = data.frame(cbind(1:n),
                             cbind(runif(n,0,1),
                             runif(n,0,1),
                             rbinom(n,1,starting_infected_prob)),
                             cbind(rep(0,n)))

colnames(starting_values) = c("id","x","y","infected","susceptible")

#this plot represents the random distribution of 2000 people in a 1km^2 area, with the blue dots being the infected individuals. Instead of trying to track progression of time, as the paper illustrates, my thought was to randomize the dot locations each iteration. Each iteration represents a day. The infected individual will be in another random location each day. 
ggplot() + geom_point(aes(starting_values[,2],starting_values[,3],colour = starting_values[,4])) + xlab("x coordinate") + ylab("y coordinate")
```


```{r}

#this calculates the distance from an infected individual
point_dist = function(x1,y1,x2,y2){
  val = sqrt((x2-x1)^2+(y2-y1)^2)
  return(val)
}

#calculates the probability of infection
#d = current distance from infected, dr = critical value to achieve certain probability of infection
probability_of_infection = function(d,dr){
  sigmoid = 1/(1+d*exp(d-dr))
  return(sigmoid)
}

#returns data frame of current infected infected individuals
infected_idx = function(df){
  idx = df[df$infected==1,]
  return(idx)
}


#this function returns a data frame of indexes of people considered susceptible. This function aims to calculate the distances of k neighbors then returns a df of indecies of those in neighborhood. We will need to keep a running track of the id's of susceptible neighbors and later factor in the probability of becoming infected.
sus = function(df,idx){
  
  dist_arr = point_dist(df[,2],df[,3],df[idx,2],df[idx,3])
  nn = kNN(dist_arr,k = 9)
  nnidx = nn$id[idx,]
  return(nnidx)
}

#estimate the probability one recovers
recovered = function(df){
  #lower probability of contracting again
}


update_infected = function(indx,state){
  starting_values[,4] = state
}

counts = function(day,count){
  vals = c(day,count)
  return(vals)
}

```

``` {r}
simulator = function(start,b,days){
  infected_df = cbind(c(1:days),c(rep(NA,days)))
  
  for(i in 1:days){
    current_infected = infected_idx(start)
    #list of neighbors close to infected with id, and distance from infected. 
    
    #calculate 
    
  }
  
}
```

```{r}

```